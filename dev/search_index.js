var documenterSearchIndex = {"docs":
[{"location":"cli/#Cli-Interface","page":"CLI Interface","title":"Cli Interface","text":"","category":"section"},{"location":"cli/","page":"CLI Interface","title":"CLI Interface","text":"The cli Interface can be accessed globaly after running julia --project build/build.jl install.","category":"page"},{"location":"cli/","page":"CLI Interface","title":"CLI Interface","text":"\t~/.julia/bin/mlnanoshaper train [options] [flags]","category":"page"},{"location":"cli/","page":"CLI Interface","title":"CLI Interface","text":"Train a model.","category":"page"},{"location":"cli/#Intro","page":"CLI Interface","title":"Intro","text":"","category":"section"},{"location":"cli/","page":"CLI Interface","title":"CLI Interface","text":"Train a model that can reconstruct a protein surface using Machine Learning. Default value of parameters are specified in the param/param.toml file. In order to override the param, you can use the differents options. ","category":"page"},{"location":"cli/#Options","page":"CLI Interface","title":"Options","text":"","category":"section"},{"location":"cli/","page":"CLI Interface","title":"CLI Interface","text":"--nb_epoch NB_EPOCH   the number of epochs to compute (type: Int64,                         default: 0)   --batch_size BATCH_SIZE                         the size of the batch, must be configured in                         function of VRAM size (type: Int64, default:                         0)   -m, --model MODEL     the model name (default: \"\")   --van_der_waals_channel                         whether to use van der Waals channel   --smoothing           whether to enforce smoothing   --nb_data_points NB_DATA_POINTS                         the number of proteins in the dataset to use                         (type: Int64, default: 0)   -n, --name NAME       name of the training run (default: \"\")   -c, --cutoff_radius CUTOFF_RADIUS                         the cutoff_radius used in training (type:                         Float32, default: 0.0)   --ref_distance REF_DISTANCE                         the reference distance (in A) used to rescale                         distance to surface in loss (type: Float32,                         default: 0.0)   --loss LOSS           the loss function (default: \"categorical\")   -l, --learning_rate LEARNING_RATE                         the learning rate used by the model in                         training (type: Float64, default: 1.0e-5)   -g, --on_gpu          should we do the training on the gpu   -h, --help            show this help message and exit","category":"page"},{"location":"loss/#Building-custom-loss-functions","page":"Custom Loss","title":"Building custom loss functions","text":"","category":"section"},{"location":"loss/","page":"Custom Loss","title":"Custom Loss","text":"A loss function is a function that take as input a lux layer, the parameters and state, a named tuple containing the points where the model is evaluated, the preprocessed input and the algebric distance to the surface. The loss function then return 2 values:","category":"page"},{"location":"loss/","page":"Custom Loss","title":"Custom Loss","text":"the loss : a scalar number\nthe state of the model\na nambed tuple containing evaluations metrics","category":"page"},{"location":"loss/","page":"Custom Loss","title":"Custom Loss","text":"function custom_loss(model,\n        ps,\n        st,\n        (;  inputs,\n            d_reals))::Tuple{\n        Float32, Any, CategoricalMetric}\n    # model evaluation\n    v_pred, st = Lux.apply(model, inputs, ps, st)\n    v_pred = vcat(v_pred, 1 .- v_pred)\n    v_pred = cpu_device()(v_pred)\n    probabilities = ignore_derivatives() do\n        generate_true_probabilities(d_reals)\n    end\n    (KL(probabilities, v_pred) |> mean,\n        st, (;))\nend","category":"page"},{"location":"loss/","page":"Custom Loss","title":"Custom Loss","text":"Once we have the loss function we need to register it in order to use in at the command line level.","category":"page"},{"location":"loss/","page":"Custom Loss","title":"Custom Loss","text":"First we need a type to represent the loss function.","category":"page"},{"location":"loss/","page":"Custom Loss","title":"Custom Loss","text":"struct CustomLoss <: LossType end","category":"page"},{"location":"loss/","page":"Custom Loss","title":"Custom Loss","text":"Then we need to give the type of metric used by the model. In our case it is a empty NamedTuple.","category":"page"},{"location":"loss/","page":"Custom Loss","title":"Custom Loss","text":"_metric_type(::Type{CustomLoss}) = @NamedTuple{}","category":"page"},{"location":"loss/","page":"Custom Loss","title":"Custom Loss","text":"We need to associate the loss function to our new type.","category":"page"},{"location":"loss/","page":"Custom Loss","title":"Custom Loss","text":"get_loss_fn(::CustomLoss) = custom_loss","category":"page"},{"location":"loss/","page":"Custom Loss","title":"Custom Loss","text":"At the end we need to give the name that will be used at the command line level to select our loss.","category":"page"},{"location":"loss/","page":"Custom Loss","title":"Custom Loss","text":"_get_loss_type(::StaticSymbol{:custom}) = CustomLoss()","category":"page"},{"location":"so/#Interfacing-with-C-code","page":"C Interface","title":"Interfacing with C code","text":"","category":"section"},{"location":"so/","page":"C Interface","title":"C Interface","text":"The code in MLNanoShaperRunner can be compiled to run as a shared object and ca be interfaced as a shared library.","category":"page"},{"location":"so/","page":"C Interface","title":"C Interface","text":"The first step is to compile the code.","category":"page"},{"location":"so/","page":"C Interface","title":"C Interface","text":"julia --project MLNanoShaperRunner/build/build.jl","category":"page"},{"location":"so/","page":"C Interface","title":"C Interface","text":"Once this is done, we have muliple directory in MLNanoShaperRunner/build/lib.","category":"page"},{"location":"so/","page":"C Interface","title":"C Interface","text":"include which contains the headers to be included in the C code.\nlib which contains the shared objects that need to be referenced by the code.\nshared which contains the artefacts necessary for the julia code. A copy of the shared directory must be included in the root project of the executable.","category":"page"},{"location":"so/#Interface","page":"C Interface","title":"Interface","text":"","category":"section"},{"location":"so/","page":"C Interface","title":"C Interface","text":"First the Interface code define some structures.","category":"page"},{"location":"so/","page":"C Interface","title":"C Interface","text":"typedef struct {\n  float x;\n  float y;\n  float z;\n  float r;\n} sphere;","category":"page"},{"location":"so/","page":"C Interface","title":"C Interface","text":"and","category":"page"},{"location":"so/","page":"C Interface","title":"C Interface","text":"typedef struct {\n  float x;\n  float y;\n  float z;\n} point;","category":"page"},{"location":"so/","page":"C Interface","title":"C Interface","text":"int load_model(char *path);","category":"page"},{"location":"so/","page":"C Interface","title":"C Interface","text":"Load the model parameters form a serialised training state at absolute path path. Parameters: path - the path to a serialized NamedTyple containing the parameters of the model Return value(int):","category":"page"},{"location":"so/","page":"C Interface","title":"C Interface","text":"0: OK\n1: file not found\n2: file could not be deserialized properly\n3: unknow error","category":"page"},{"location":"so/","page":"C Interface","title":"C Interface","text":"int load_atoms(sphere *start, int length);","category":"page"},{"location":"so/","page":"C Interface","title":"C Interface","text":"Load the atoms into the julia model. Start is a pointer to the start of the array of sphere and length is the length of the array","category":"page"},{"location":"so/#Return-an-error-status:","page":"C Interface","title":"Return an error status:","text":"","category":"section"},{"location":"so/","page":"C Interface","title":"C Interface","text":"0: OK\n1: data could not be read\n2: unknow error","category":"page"},{"location":"so/","page":"C Interface","title":"C Interface","text":"float eval_model(point *start,int length); ","category":"page"},{"location":"so/","page":"C Interface","title":"C Interface","text":"evaluate the model at coordinates start[0],...,start[length -1]","category":"page"},{"location":"so/#Example","page":"C Interface","title":"Example","text":"","category":"section"},{"location":"so/","page":"C Interface","title":"C Interface","text":"#include \"MLNanoShaperRunner.h\"\n#include \"julia_init.h\"\n\nint main(int argc,char *argv[]) {\n  init_julia(argc, argv);\n  load_model(\"/home/tristan/datasets/models/\"\n               \"angular_dense_2Apf_epoch_10_16451353003083222301\");\n  sphere data[2]= {{0.,0.,0.,1.},{1.,0.,0.,1.}};\n  load_atoms(data,2);\n  point x[2] = {{0.,0.,1.},{1.,0.,0.}};\n  eval_model(x,2);\n  shutdown_julia(0);\n  return 0;\n}","category":"page"},{"location":"model/#Building-a-new-model","page":"Building Custom Models","title":"Building a new model","text":"","category":"section"},{"location":"model/","page":"Building Custom Models","title":"Building Custom Models","text":"In order to create a new model, we need to create a new function that returns a Lux.Abstractlayer in the MLNanoShaperModule. The function must take as input at least a name, van_der_waals_channel, on_gpu,and cutoff_radius.","category":"page"},{"location":"model/","page":"Building Custom Models","title":"Building Custom Models","text":"function custom_angular_dense(; name::String,\n        van_der_waals_channel = false, on_gpu = true, cutoff_radius::Float32 = 3.0f0)\n    main_chain = Parallel(.*,\n            Chain(Dense(6 => 10, elu),\n                Dense(10 => 5, elu)),\n            Lux.WrappedFunction{:direct_call}(scale_factor)\n    )\n    main_chain = DeepSet(Chain(\n        symetrise(; cutoff_radius, device = on_gpu ? gpu_device() : identity),\n        main_chain\n    ))\n    secondary_chain = Chain(\n            BatchNorm(5),\n            Dense(5  => 10, elu),\n            Dense(10 => 1, sigmoid_fast));\n    Chain(PreprocessingLayer(Partial(select_and_preprocess; cutoff_radius)),\n        main_chain,\n        secondary_chain;\n        name)\nend","category":"page"},{"location":"model/","page":"Building Custom Models","title":"Building Custom Models","text":"Once this is done you can call the model by using the flag --model with the name of the function created. In our case --model custom_angular_dense.","category":"page"},{"location":"#MLNanoShaper","page":"Home","title":"MLNanoShaper","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for MLNanoShaper. MLNanoShaper is a machine learning algorithm that can compute the surface of proteins.   There are multiple ways to interface with the software.","category":"page"},{"location":"","page":"Home","title":"Home","text":"As julia Modules MLNanoShaper and MLNanoShaperRunner\nAs a cli command mlnanoshaper in ~/.julia/bin.\nAs a training script script/training.bash that run multiple training runs. Requires parallel.\nRunning only: as a .so object.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#MLNanoShaper.AccumulatorLogger","page":"Home","title":"MLNanoShaper.AccumulatorLogger","text":"accumulator(processing,logger)\n\nA processing logger that transform logger on multiple batches Ca be used to liss numerical data, for logging to TensorBoardLogger.\n\n\n\n\n\n","category":"type"},{"location":"#MLNanoShaper.AdamDelta","page":"Home","title":"MLNanoShaper.AdamDelta","text":"AdamDelta(ρ = 0.9, ϵ = 1e-8)\nAdaDelta(; [rho, epsilon])\n\nParameters\n\nRho (ρ == rho): Factor by which the gradient is decayed at each time step.\nMachine epsilon (ϵ == epsilon): Constant to prevent division by zero                        (no need to change default)\n\n\n\n\n\n","category":"type"},{"location":"#MLNanoShaper.AnnotedKDTree","page":"Home","title":"MLNanoShaper.AnnotedKDTree","text":"AnnotedKDTree(data::StructVector,property::StaticSymbol)\n\nFields\n\ndata::StructVector\ntree::KDTree\n\n\n\n\n\n","category":"type"},{"location":"#MLNanoShaper.AuxiliaryParameters","page":"Home","title":"MLNanoShaper.AuxiliaryParameters","text":"AuxiliaryParameters\n\nThe variables that do not influence the outome of the training run. This include the nb_epoch.\n\n\n\n\n\n","category":"type"},{"location":"#MLNanoShaper.LossType","page":"Home","title":"MLNanoShaper.LossType","text":"abstract type LossType end\n\nLossType is an interface for defining loss functions.\n\nImplementation\n\ngetlossfn(::LossType)::Function : the associated loss function\nmetrictype(::Type{<:LossType)::Type : the type of metrics returned by the loss function\ngetlosstype(::StaticSymbol)::LossType : the function generating the losstype\n\n\n\n\n\n","category":"type"},{"location":"#MLNanoShaper.TrainingData","page":"Home","title":"MLNanoShaper.TrainingData","text":"Training information used in model training.\n\nFields\n\natoms: the set of atoms used as model input\nskin : the Surface generated by Nanoshaper\n\n\n\n\n\n","category":"type"},{"location":"#MLNanoShaper.TrainingParameters","page":"Home","title":"MLNanoShaper.TrainingParameters","text":"TrainingParameters\n\nThe training parameters used in the model training. Default values are in the param file. The training is deterministric. Theses values are hased to determine a training run\n\n\n\n\n\n","category":"type"},{"location":"#MLNanoShaper._train-Tuple{MLNanoShaper.TrainingParameters, MLNanoShaper.AuxiliaryParameters}","page":"Home","title":"MLNanoShaper._train","text":"_train(training_parameters::TrainingParameters, directories::AuxiliaryParameters)\n\ntrain the model given TrainingParameters and AuxiliaryParameters.\n\n\n\n\n\n","category":"method"},{"location":"#MLNanoShaper.categorical_loss-NTuple{4, Any}","page":"Home","title":"MLNanoShaper.categorical_loss","text":"categorical_loss(model, ps, st, (; point, atoms, d_real))\n\nThe loss function used by in training. Return the KL divergence between true probability and empirical probability Return the error with the espected distance as a metric.\n\n\n\n\n\n","category":"method"},{"location":"#MLNanoShaper.continuous_loss-NTuple{4, Any}","page":"Home","title":"MLNanoShaper.continuous_loss","text":"continus_loss(model, ps, st, (; point, atoms, d_real))\n\nThe loss function used by in training. compare the predicted (square) distance with frac1 + \tanh(d)2 Return the error with the espected distance as a metric.\n\n\n\n\n\n","category":"method"},{"location":"#MLNanoShaper.distance-Tuple{AbstractVector{<:AbstractVector}, NearestNeighbors.KDTree}","page":"Home","title":"MLNanoShaper.distance","text":"distance(x::GeometryBasics.Mesh, y::KDTree)\n\nReturn the Hausdorff distance betwen the mesh coordinates\n\n\n\n\n\n","category":"method"},{"location":"#MLNanoShaper.generate_data-Tuple{}","page":"Home","title":"MLNanoShaper.generate_data","text":"generate_data()\n\ngenerate data from the parameters files in param/ by downloading the pdb files and running Nanoshaper. \n\n\n\n\n\n","category":"method"},{"location":"#MLNanoShaper.generate_data_points-Tuple{LuxCore.AbstractLuxLayer, AbstractVector{GeometryBasics.Point{3, Float32}}, MLNanoShaper.TreeTrainingData{Float32}, MLNanoShaper.TrainingParameters}","page":"Home","title":"MLNanoShaper.generate_data_points","text":"generate_data_points(\n    preprocessing::Lux.AbstractExplicitLayer, points::AbstractVector{<:Point3},\n    (; atoms, skin)::TreeTrainingData{Float32}, (; ref_distance)::TrainingParameters)\n\ngenerate the data_points for a set of positions points on one protein.\n\n\n\n\n\n","category":"method"},{"location":"#MLNanoShaper.implicit_surface-Union{Tuple{T}, Tuple{Lux.StatefulLuxLayer, MLNanoShaperRunner.RegularGrid{T}}} where T","page":"Home","title":"MLNanoShaper.implicit_surface","text":"implicit_surface(atoms::RegularGrid{T},\n    model::Lux.StatefulLuxLayer, (;\n        cutoff_radius, step)) where {T}\n\nCreate a mesh form the isosurface of function `pos -> model(atoms,pos)` using marching cubes algorithm and using step size `step`.\n\n\n\n\n\n","category":"method"},{"location":"#MLNanoShaper.load_data_pqr-Tuple{Type{<:Number}, String}","page":"Home","title":"MLNanoShaper.load_data_pqr","text":"load_data_pqr(T, name::String)\n\nLoad a TrainingData{T} from current directory. You should have a pdb and an off file with name name in current directory.\n\n\n\n\n\n","category":"method"},{"location":"#MLNanoShaper.signed_distance-Union{Tuple{T}, Tuple{GeometryBasics.Point3{T}, MLNanoShaper.RegionMesh}} where T<:Number","page":"Home","title":"MLNanoShaper.signed_distance","text":"signed_distance(p::Point3, mesh::RegionMesh)::Number\n\nreturns the signed distance between point p and the mesh a positive distance means that we are inside the mesh\n\n\n\n\n\n","category":"method"},{"location":"#MLNanoShaperRunner.Option","page":"Home","title":"MLNanoShaperRunner.Option","text":"state\n\nThe global state manipulated by the c interface. To use, you must first load the weights using load_weights and the input atoms using load_atoms. Then you can call eval_model to get the field on a certain point.\n\n\n\n\n\n","category":"type"},{"location":"#MLNanoShaperRunner.Batch","page":"Home","title":"MLNanoShaperRunner.Batch","text":"Batch  A wrapper arround a vector to design a variable dimension\n\n\n\n\n\n","category":"type"},{"location":"#MLNanoShaperRunner.ConcatenatedBatch","page":"Home","title":"MLNanoShaperRunner.ConcatenatedBatch","text":"ConcatenatedBatch\n\nRepresent a vector of arrays of sizes (a..., bn) where bn is the variable dimension of the batch. You can access view of individual arrays with get_slice.\n\n\n\n\n\n","category":"type"},{"location":"#MLNanoShaperRunner.ModelInput","page":"Home","title":"MLNanoShaperRunner.ModelInput","text":"ModelInput\n\ninput of the model\n\nFields\n\npoint::Point3, the position of the input\natoms::StructVector{Sphere}, the atoms in the neighboord\n\n\n\n\n\n","category":"type"},{"location":"#MLNanoShaperRunner.RegularGrid","page":"Home","title":"MLNanoShaperRunner.RegularGrid","text":"struct RegularGrid{T<:Number,G,F<:Function}\n\nA structure representing the input of the surface prediction model\n\n\n\n\n\n","category":"type"},{"location":"#MLNanoShaperRunner.RegularGrid-Union{Tuple{G}, Tuple{T}, Tuple{AbstractVector{G}, T}, Tuple{AbstractVector{G}, T, Function}} where {T, G}","page":"Home","title":"MLNanoShaperRunner.RegularGrid","text":"RegularGrid(spheres::AbstractVector,radius::Number,[center])  A constructor that take a vector of spheres. If you are not using Geometry basic spheres, you will need to give a function center that return the center of each point.\n\n\n\n\n\n","category":"method"},{"location":"#MLNanoShaperRunner.batched_sum-Tuple{AbstractMatrix, Any, AbstractVector}","page":"Home","title":"MLNanoShaperRunner.batched_sum","text":"batched_sum(b::AbstractMatrix,nb_elements::AbstractVector)\n\ncompute the sum of a Concatenated batch with ndim  = 2. The first dim is the feature dimension. The second dim is the the batch dim.\n\nGiven b of size (n,m) and nb_elements of size (k,), the output has size (n,k).\n\n\n\n\n\n","category":"method"},{"location":"#MLNanoShaperRunner.eval_model","page":"Home","title":"MLNanoShaperRunner.eval_model","text":"eval_model(x::Float32,y::Float32,z::Float32)::Float32\n\nevaluate the model at coordinates x y z.\n\n\n\n\n\n","category":"function"},{"location":"#MLNanoShaperRunner.eval_model-Tuple{Ptr{MLNanoShaperRunner.CPoint}, Int32}","page":"Home","title":"MLNanoShaperRunner.eval_model","text":"evaluate_model\n\n\n\n\n\n","category":"method"},{"location":"#MLNanoShaperRunner.get_cutoff_radius-Tuple{LuxCore.AbstractLuxLayer}","page":"Home","title":"MLNanoShaperRunner.get_cutoff_radius","text":"get_cutoff_radius(x::Lux.AbstractLuxLayer)\n\nextract the cutoff radius of a Lux Model.\n\n\n\n\n\n","category":"method"},{"location":"#MLNanoShaperRunner.light_angular_dense-Tuple{}","page":"Home","title":"MLNanoShaperRunner.light_angular_dense","text":"light_angular_dense(; categorical=false, van_der_waals_channel=false, kargs...)\n\n`light_angular_dense` is a function that generate a lux model.\n\n\n\n\n\n","category":"method"},{"location":"#MLNanoShaperRunner.light_soft_max_angular_dense-Tuple{}","page":"Home","title":"MLNanoShaperRunner.light_soft_max_angular_dense","text":"light_soft_max_angular_dense(; categorical=false, van_der_waals_channel=false, kargs...)\n\n`light_soft_max_angular_dense` is a function that generate a lux model.\n\n\n\n\n\n","category":"method"},{"location":"#MLNanoShaperRunner.load_atoms","page":"Home","title":"MLNanoShaperRunner.load_atoms","text":"load_atoms(start::Ptr{CSphere},length::Cint)::Cint\n\nLoad the atoms into the julia model. Start is a pointer to the start of the array of CSphere and length is the length of the array\n\nReturn an error status:\n\n0: OK\n1: data could not be read\n2: unknow error\n\n\n\n\n\n","category":"function"},{"location":"#MLNanoShaperRunner.load_model","page":"Home","title":"MLNanoShaperRunner.load_model","text":"load_model(path::String)::Cint\n\nLoad the model from a MLNanoShaperRunner.SerializedModel serialized state at absolute path path.\n\nReturn an error status:\n\n0: OK\n1: file not found\n2: file could not be deserialized properly\n3: unknow error\n\n\n\n\n\n","category":"function"},{"location":"#MLNanoShaperRunner.medium_angular_dense-Tuple{}","page":"Home","title":"MLNanoShaperRunner.medium_angular_dense","text":"medium_angular_dense(; categorical=false, van_der_waals_channel=false, kargs...)\n\n`medium_angular_dense` is a function that generate a lux model.\n\n\n\n\n\n","category":"method"},{"location":"#MLNanoShaperRunner.production_instantiate-Tuple{MLNanoShaperRunner.SerializedModel}","page":"Home","title":"MLNanoShaperRunner.production_instantiate","text":"production_instantiate(model::SerializedModel;[on_gpu])::Lux.StatefullLuxLayer{true}\n\nTurn a SerializedModel into a Stateful Lux Layer. \n\n\n\n\n\n","category":"method"},{"location":"#MLNanoShaperRunner.tiny_angular_dense-Tuple{}","page":"Home","title":"MLNanoShaperRunner.tiny_angular_dense","text":"tiny_angular_dense(; categorical=false, van_der_waals_channel=false, kargs...)\n\n`tiny_angular_dense` is a function that generate a lux model.\n\n\n\n\n\n","category":"method"},{"location":"#MLNanoShaperRunner.tiny_soft_max_angular_dense-Tuple{}","page":"Home","title":"MLNanoShaperRunner.tiny_soft_max_angular_dense","text":"tiny_angular_dense(; categorical=false, van_der_waals_channel=false, kargs...)\n\n`tiny_angular_dense` is a function that generate a lux model.\n\n\n\n\n\n","category":"method"},{"location":"evaluation/#Model-evaluation","page":"model evaluation","title":"Model evaluation","text":"","category":"section"},{"location":"evaluation/","page":"model evaluation","title":"model evaluation","text":"Model are stored as serialized objects containing the parameters, weights, and a partial application to evaluate the model ( it is done this way to prevent serialization of anonymous functions that behave badly with serialization). Given a path path, we first deserialize de model to get a SerializedModel and turn it into a Lux StatefullLuxLayer with productioninstantiate. Since preprocessing is part of the model, the input is alway on the cpu but the output might be on gpu and  must be moved to cpu with `cpudevice().  To evaluate the model, starting from a vector of spheres,you will useRegularGrid` to create a regular grid. To evaluate points, they must be dispatched within a batch. Here is an example of evaluation.","category":"page"},{"location":"evaluation/","page":"model evaluation","title":"model evaluation","text":"function evaluate_field(model_path::AbstractString,atoms::Vector{Sphere{Float32}};step::Number=1,batch_size = 100000)::Array{Float32,3}\n  model = production_instantiate(deserialize(model_path))\n  atoms = RegularGrid(aatoms,get_cutoff_radius(model.model))\n\tmins = atoms.start .- 2\n\tmaxes = mins .+ size(atoms.grid) .* atoms.radius .+ 2\n    ranges = range.(mins, maxes; step)\n    grid = Point3f.(reshape(ranges[1], :, 1,1), reshape(ranges[2], 1, :,1), reshape(ranges[3], 1,1,:))\n    g = vec(grid)\n    volume = similar(grid,Float32)\n    v = reshape(volume,:)\n    # @info \"comparing lengths\" length(volume)/batch_size \n    for i in 1:batch_size:length(volume)\n    \tk = min(i+ batch_size-1,length(v))\n    \tres =  model((Batch(view(g,i:k)), atoms)) |> cpu_device() |> vec\n    \tv[i:k] .= res\n        end\n\tvolume\nend","category":"page"}]
}
