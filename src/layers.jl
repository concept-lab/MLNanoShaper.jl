using Lux
using ConcreteStructs
using GeometryBasics
using Random
using SimpleChains: static
using Adapt
using ChainRulesCore

@concrete struct DeepSet <: Lux.AbstractExplicitContainerLayer{(:prepross,)}
    prepross
end

function (f::DeepSet)(set::AbstractArray{T}, ps, st) where {T}
	trace("input size",length(set))
    sum(set) do arg
        Lux.apply(f.prepross, arg, ps, st) |> first
	end/sqrt(length(set)), st
end

"""
Training information used in model training.
# Fields
- `atoms`: the set of atoms used as model input
- `skin` : the Surface generated by Nanoshaper
"""
struct TrainingData{T <: Number}
    atoms::Vector{Sphere{T}}
    skin::GeometryBasics.Mesh
end
struct ModelInput{T <: Number}
    point::Point3{T}
    atoms::Vector{Sphere{T}} #Set
end

struct PreprocessData{T <: Number}
    dot::T
    r_1::T
    r_2::T
    d_1::T
    d_2::T
end

# Inputs
# - `(;point,atoms)`: `ModelInput`, a point in 3 space and a vector of spheres.
"""
Encoding(n_dotₛ,n_Dₛ,cut_distance)

A lux layer which embed angular and radial `PreprocessData` into a feature vector invariant by translation and rotations.

# Arguments
- `n_dotₛ`: Integer specifying the number of anguar features 
- `n_Dₛ`: Integer specifying the number of radial features 
- `cut_distance`: The maximun distance of intaraction between atoms 
# Input
- `(;dot,r_1,r_2,d_1,d_2)`:`PreprocessData`, the dot product,the atoms radii and the distances between the reference point and the atoms. 
# Output
- `x`: a `Vector` representing the encoded features:
```math
x_{ij} = (\\frac{1}{2} + \\frac{dot - dot_{si}}{4})^\\eta * \\exp(-\\zeta ~ ( \\frac{d_1 + d_2}{2} - D_{si} ) ) \\times cut(d_1) \\times cut(d_2) 
```
"""
struct Encoding{T <: Number} <: Lux.AbstractExplicitLayer
    n_dotₛ::Int
    n_Dₛ::Int
    cut_distance::T
end

function Lux.initialparameters(::AbstractRNG, l::Encoding{T}) where {T}
    (dotsₛ = reshape(collect(range(T(0), T(1); length = l.n_dotₛ)), 1, :),
        Dₛ = reshape(collect(range(T(0), l.cut_distance; length = l.n_Dₛ)), :, 1),
        η = reshape([T(1) / l.n_Dₛ], 1, 1),
        ζ = reshape([T(1) / l.n_dotₛ], 1, 1))
end
Lux.initialstates(::AbstractRNG, l::Encoding) = (;)

function (l::Encoding{T})((; dot, d_1, d_2, r_1, r_2)::PreprocessData{T},
        (; dotsₛ, η, ζ, Dₛ),
        st) where {T}
    encoded = ((2 .+ dot .- tanh.(dotsₛ)) ./ 4) .^ ζ .*
              exp.(-η .* ((d_1 + d_2) / 2 .- Dₛ) .^ 2) .*
              cut(l.cut_distance, d_1) .*
              cut(l.cut_distance, d_2)
    res = vcat(vec(encoded), [(r_1 + r_2) / 2, abs(r_1 - r_2)])
    res, st
end

function cut(cut_radius::Number, r::Number)
    if r >= cut_radius
        zero(r)
    else
        (1 + cos(π * r / cut_radius)) / 2
    end
end

function preprocessing((; point, atoms)::ModelInput)
    map(Iterators.product(atoms, atoms)) do (atom1, atom2)::Tuple{Sphere, Sphere}
        d_1 = sqrt(distance2(point, atom1.center))
        d_2 = sqrt(distance2(point, atom2.center))
        dot = (atom1.center - point) ⋅ (atom2.center - point) / (d_1 * d_2 + 1.0f-8)
        PreprocessData(dot, atom1.r, atom2.r, d_1, d_2)
    end
end
function trace(message::String, x)
    @info message x
    x
end

trace(message::String) = x ->trace(message,x)
function ChainRulesCore.rrule(::typeof(trace), message, x)
    y = trace(message, x)
    function trace_pullback(y_hat)
        NoTangent(), NoTangent(), y_hat
    end
    return y, trace_pullback
end

postprocess(x) = ifelse.(x .<= 0, zero(eltype(x)), exp.(-1 ./ x))
