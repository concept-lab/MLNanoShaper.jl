struct RegionMesh
    triangles::Vector{TriangleFace{Point3f}}
    tree::KDTree
end
function RegionMesh(mesh::GeometryBasics.Mesh)
    triangles = Vector{TriangleFace{Point3f}}(undef, length(coordinates(mesh)))
    for (j, tri) in enumerate(faces(mesh))
        ctri = map(tri) do j
            coordinates(mesh)[j]
        end
        for i in tri
            triangles[i] = ctri
        end
    end
    RegionMesh(triangles,
        KDTree(coordinates(mesh); reorder=false))
end

"""
Training information used in model training.
# Fields
- `atoms`: the set of atoms used as model input
- `skin` : the Surface generated by Nanoshaper
"""
struct TrainingData{T <: Number}
    atoms::StructVector{Sphere{T}}
    skin::GeometryBasics.Mesh
end


"""
	AnnotedKDTree(data::StructVector,property::StaticSymbol)
# Fields
- data::StructVector
- tree::KDTree
"""
struct AnnotedKDTree{Type,Property,Subtype}
    data::StructVector{Type}
    tree::KDTree{Subtype}
    function AnnotedKDTree(data::StructVector, property::StaticSymbol)
        new{eltype(data),dynamic(property),
            eltype(getproperty(StructArrays.components(data), dynamic(property)))}(
            data, KDTree(getproperty(data, dynamic(property)); reorder=false))
    end
end
struct TreeTrainingData{T <: Number}
    atoms_grid::RegularGrid{T}
    atoms_tree::AnnotedKDTree{Sphere{T},:center,Point3{T}}
    skin::RegionMesh
end
function TreeTrainingData((; atoms, skin)::TrainingData{T},radius::T) where T
    TreeTrainingData(RegularGrid(atoms,radius),AnnotedKDTree(atoms,static(:center)), RegionMesh(skin))
end
function point_grid(mins::AbstractVector, maxes, scale::Number)
    Iterators.product(range.(mins,
        maxes
        ; step = scale)...) .|> Point3
end
function approximates_points(predicate, rng::AbstractRNG, atoms_tree::KDTree,
        skin_tree::KDTree{Point3f},
        (; scale,
            cutoff_radius)::TrainingParameters)
    (; mins, maxes) = atoms_tree.hyper_rec
    points = shuffle( rng, point_grid(mins, maxes, scale))
    Iterators.filter(points) do point
        distance(point, atoms_tree) < cutoff_radius &&
            predicate(point)
    end
end

function exact_points(
        rng::AbstractRNG, atoms_tree::KDTree, skin_tree::KDTree, (;
            cutoff_radius)::TrainingParameters)
    points = shuffle(rng, skin_tree.data)
    Iterators.filter(points) do pt
        distance(pt, atoms_tree) < cutoff_radius
    end
end
function aggregate_input_data(vec::AbstractVector{T})::T where {T <: GlobalPreprocessed}
    (; inputs, d_reals) = vec |> StructVector
    inputs = MLNanoShaperRunner.stack_ConcatenatedBatch(inputs)
    d_reals = reduce(vcat, d_reals)
    (; inputs, d_reals)
end
"""
    generate_data_points(
        preprocessing::Lux.AbstractExplicitLayer, points::AbstractVector{<:Point3},
        (; atoms, skin)::TreeTrainingData{Float32}, (; ref_distance)::TrainingParameters)

generate the data_points for a set of positions `points` on one protein.
"""
function generate_data_points(
        preprocessing::Lux.AbstractLuxLayer, points::AbstractVector{Point3f},
        (;atoms_grid, atoms_tree, skin)::TreeTrainingData{Float32}, (; ref_distance)::TrainingParameters)::GlobalPreprocessed
    (;
        inputs = preprocessing((Batch(points), atoms_grid)),
        d_reals = signed_distance.(points, Ref(skin)) ./ ref_distance
    )
end
function pre_compute_data_set(points_generator::Function,
        preprocessing,
        dataset::AbstractVector{<:TreeTrainingData{Float32}}, training_parameters::TrainingParameters)::GlobalPreprocessed
    Folds.map(dataset) do protein_data::TreeTrainingData
        points::AbstractVector{<:Point3} = points_generator(protein_data)
        generate_data_points(
            preprocessing, points, protein_data, training_parameters)
    end |> aggregate_input_data
end
# """
# 	load_data_pdb(T, name::String)

# Load a `TrainingData{T}` from current directory.
# You should have a pdb and an off file with name `name` in current directory.
# """
# function load_data_pdb(T::Type{<:Number}, name::String)
#     TrainingData{T}(extract_balls(T, read("$name.pdb", PDBFormat)), load("$name.off"))
# end
"""
	load_data_pqr(T, name::String)

Load a `TrainingData{T}` from current directory.
You should have a pdb and an off file with name `name` in current directory.
"""
function load_data_pqr(T::Type{<:Number}, dir::String)
    TrainingData{T}(getproperty.(read("$dir/structure.pqr", PQR{T}), :pos) |> StructVector,
        load("$dir/triangulatedSurf.off"))
end
distance(x::AbstractVector, y::KDTree)::Number = nn(y, x) |> last

"""
    signed_distance(p::Point3, mesh::RegionMesh)::Number

returns the signed distance between point p and the mesh
a positive distance means that we are inside the mesh
"""
function signed_distance(p::Point3{T}, mesh::RegionMesh)::T where {T<:Number}
    id_point, dist = nn(mesh.tree, p)
    x, y, z = mesh.triangles[OffsetInteger{-1,UInt32}(id_point)]
    # @info "triangle" x y z

    direction = hcat(y - x, z - x, p - x) |> det |> sign
    -direction * dist
end

"""
    distance(x::GeometryBasics.Mesh, y::KDTree)

Return the Hausdorff distance betwen the mesh coordinates
"""
function distance(vec::AbstractVector{<:AbstractVector}, y::KDTree)::Number
    minimum(vec) do x
        distance(x, y)
    end
end

