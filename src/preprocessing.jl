using Lux
using Distributed: preduce
using StaticArrays: reorder
using LoggingExtras: shouldlog
using LinearAlgebra: NumberArray
using ConcreteStructs
using TOML
using GeometryBasics
using ADTypes
using Random
using LinearAlgebra
using FileIO
using Zygote
using MLUtils
using Logging
using StaticArrays
using Optimisers
using Statistics
using TensorBoardLogger
using Serialization
using Meshing
using NearestNeighbors
using StructArrays
using MLNanoShaperRunner
using Distributed
using Static

"""
Training information used in model training.
# Fields
- `atoms`: the set of atoms used as model input
- `skin` : the Surface generated by Nanoshaper
"""
struct TrainingData{T <: Number}
    atoms::StructVector{Sphere{T}}
    skin::GeometryBasics.Mesh
end

struct AnnotedKDTree{Type, Property, Subtype}
    data::StructVector{Type}
    tree::KDTree{Subtype}
    function AnnotedKDTree(data::StructVector, property::StaticSymbol)
        new{eltype(data), property}(
            data, KDTree(getproperty(data, dynamic(property)); reorder = false))
    end
end
function select_neighboord(
        point, (; data, tree)::AnnotedKDTree; cutoff_radius)
    data[inrange(tree, point, cutoff_radius)]
end
struct TreeTrainingData{T <: Number}
    atoms::AnnotedKDTree{Sphere{T}, :pos, Point3{T}}
    skin::RegionMesh
end
function TreeTrainingData((; atoms, skin)::TrainingData)
    TreeTrainingData(AnnotedKDTree(atoms, static(:pos)), RegionMesh(skin))
end

function point_grid(rng::AbstractRNG, atoms_tree::KDTree,
        skin_tree::KDTree{Point3f},
        (; scale,
            cutoff_radius)::Training_parameters)
    (; mins, maxes) = atoms_tree.hyper_rec
    Iterators.filter(
        first(shuffle(
            rng, Iterators.product(range.(mins,
                maxes
                ; step = scale)...) .|> Point3)),
        1000) do point
        distance(point, atoms_tree) < cutoff_radius &&
            distance(point, skin_tree) < cutoff_radius
    end
end

function exact_points(
        rng::AbstractRNG, atoms_tree::KDTree, skin_tree::KDTree, (;
            cutoff_radius)::Training_parameters)
    Iterators.filter(first(shuffle(rng, skin_tree.data), 200)) do pt
        distance(pt, atoms_tree) < cutoff_radius
    end
end
function generate_data_points(points,(; atoms, skin)::TreeTrainingData{Float32},
        (; scale, cutoff_radius)::Training_parameters)
    # exact_points_v = exact_points(MersenneTwister(42), atoms.tree, skin, cutoff_radius)
    # points = first(
    # point_grid(MersenneTwister(42), atoms.tree, skin.tree; scale, cutoff_radius), 40)

    mapobs(points) do point::Point3f
        (; point, atoms = select_neighboord(point, atoms, cutoff_radius),
            d_real = signed_distance(point, skin))
    end
end

function pre_compute_data_set(f::Function, data::AbstractVector{<:TreeTrainingData},
        tr::Training_parameters)::Vector{@NamedTuple{
        point::Point3f, atoms::StructVector{Sphere{Float32}}, d_real::Float32}}
    res = pmap(data) do d
        points = f(d,tr)
        collect(
            @NamedTuple{
                point::Point3f, atoms::StructVector{Sphere{Float32}}, d_real::Float32},
            generate_data_points(points,d, tr))
    end
    reduce(vcat, res)
end
"""
	load_data_pdb(T, name::String)

Load a `TrainingData{T}` from current directory.
You should have a pdb and an off file with name `name` in current directory.
"""
function load_data_pdb(T::Type{<:Number}, name::String)
    TrainingData{T}(extract_balls(T, read("$name.pdb", PDB)), load("$name.off"))
end
"""
	load_data_pqr(T, name::String)

Load a `TrainingData{T}` from current directory.
You should have a pdb and an off file with name `name` in current directory.
"""
function load_data_pqr(T::Type{<:Number}, dir::String)
    TrainingData{T}(getproperty.(read("$dir/structure.pqr", PQR{T}), :pos) |> StructVector,
        load("$dir/triangulatedSurf.off"))
end

